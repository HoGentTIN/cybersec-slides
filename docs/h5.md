---
title: "Hoofdstuk 5"
---

# Hoofdstuk 5: Integrity

Het verzekeren van integriteit

---

# 5.1 Digitale handtekening

---
## Digitale handtekening

-  Aan bestanden (bv: PDF) kan een **digitale handtekening** toegevoegd worden voor het verzekeren van **integriteit**.
- Hiermee kunnen twee zaken gecontroleerd worden:
    - Het bestand is **niet gewijzigd** nadat de handtekening is gegenereerd
    - Het bestand is daadwerkelijk **afkomstig van de persoon** die de handtekening heeft gegenereerd, en niet van iemand anders
- Om dit te realiseren wordt een **asymetrisch algoritme** (public-key encryption) gebruikt (zie **H4** )
---

## Hoe werkt dit?

Asymmetrische encryptie genereert een **publieke** en **private** sleutel per persoon. Deze sleutels zijn wiskundig aan elkaar gelinkt.

<div class="multicolumn">
<div>

<img src="./img/h5/assym_key_encrypt_decrypt.png" class="r-stretch" />

</div>
<div>

<img src="./img/h5/assym_key_sign_verify.png" class="r-stretch" />


</div>
</div>
---

## Hoe werkt dit?

- Aan het bericht van Alice wordt een digitale handtekening toegevoegd, deze wordt geëncrypteerd met de **private sleutel** van Alice. 
- De **publieke sleutel** van Alice kan gebruikt worden om de handtekening te decrypteren. De handtekening wordt bovendien ongeldig zodra er iets wijzigt in het bericht, dus zo kan iedereen die dit wil verifieren dat het **bericht niet gewijzigd** is.
Omdat je de private sleutel van Alice nodig hebt om de handtekening te maken, is het bericht dus **afkomstig van Alice**.

Merk op dat dit geen vertrouwelijkheid (confidentiality) toevoegt, maar dit kan gerealiseerd worden door het bericht na toevoegen van de handtekening te encrypteren met de publieke sleutel van de ontvanger (Bob).

---

## Voorbeeld sleutelpaar

Normaal gebruik je hiervoor software op jouw eigen computer (GPG). **Genereer nooit jouw sleutels via een website voor echt gebruik!**
<div class="multicolumn">
<div>


```
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: OpenPGP v2.0.8

793hZyatESpYcgQplSrDXBBc9MZGRE9fvZE8Qvsc+r9/kpf7BLJ/
YU5xKVFkFuaSTx2k6Mwd2F6Mo9OoNcAdeS9vALjvtyD8T/EGoPRq
SQ1rbQfIi814JW7unXg...
=bGdt
-----END PGP PUBLIC KEY BLOCK-----

```
</div>
<div>


```
-----BEGIN PGP PRIVATE KEY BLOCK-----
Version: OpenPGP v2.0.8

xcaGBF9fh/EBEADk+w2xYivAYznxkZM3Rv0U0gyqj9gDbVmPloQ9f
3F/0B9Tmtwht3Z8JmwPJ++1GUUnT03mMlGYKtblVYPX1uAQItIaBN
Cyk/wZ4+T16g3rSa...
=UmmP
-----END PGP PRIVATE KEY BLOCK-----

```
</div>
</div>

---

## Voorbeeld handtekening (e-mail)

<img src="./img/h5/email_signature.png" class="r-stretch" />

Notes: 
- De handtekening hier is niet geldig, ze dient gewoon ter illustratie zodat je je kan voorstellen hoe een handtekening er uit ziet. 
In latere vakken zie je in meer detail hoe dit werkt.

---

# 5.2 Hashing algoritmes

---

## Een hash als integriteitscontrole

Om te controleren dat een bestand of bericht niet gewijzigd is,
kan een **hashing algoritme** of **hashfunctie** gebruikt worden.
Hierbij wordt een bepaalde waarde (hash) berekend en toegevoegd aan het bestand of bericht.

Op een later moment kan de hashfunctie opnieuw uitgevoerd worden, en zou de **hashwaarde niet gewijzigd** mogen zijn.

---

## Hashing algoritme
- Vormt een reeks van bits om naar een reeks van een vast aantal bits (alles in IT kan voorgesteld worden in bits).
- Het is een **wiskundige eenrichtingsfunctie**. Het is in de ene richting makkelijk te berekenen, maar onmogelijk in de andere richting
    - Je kan dit vergelijken met het vermalen van koffiebonen. Het vermalen van bonen tot gruis is gemakkelijk, maar het terug samenplakken van gruis tot bonen is onmogelijk.
    - Een ander voorbeeld is het controlecijfer in een bankrekeningnummer.
    
Notes:
- Zie https://www.iban.nl/iban-berekenen/ en https://nl.wikipedia.org/wiki/International_Bank_Account_Number voor de berekening van het controlenummer van een IBAN bankrekeningnummer.
- Controlecijfer bankrekening:  Hierbij worden de 2 cijfers na de landcode van eenIBAN bankrekeningnummer berekend aan de hand van de bankcode en de resterende getallen. Zo kunnen we controleren of het nummer geldig is (bv. BE68 5390 0754 7034).

---

##  Eigenschappen

Een hashing algoritme heeft de volgende **eigenschappen**:
- De input kan uit om het even welk aantal bits bestaan
- De output heeft steeds hetzelfde aantal bits ongeacht het aantal bits van de input)
- De hashfunctie is een eenrichtingsfunctie en is onmogelijk om te keren
- Twee verschillende inputwaarden zullen steeds een verschillende outputwaarde geven

---

## Werking hashing algoritme

<img src="./img/h5/hashing_example.png" class="r-stretch" />

Notes:
- De hier getoonde binaire waarden zijn verzonnen voor educatief inzicht. Effectieve waarden worden berekend en getoond in de praktijkopdrachten.

---

## MD5 en SHA
Populaire hashing algoritmes zijn MD5 en SHA:
- Het **Message Digest 5 Algorithm** (MD5) is ontwikkeld door Ron Rivest en geeft een 128-bits output terug
- Het **Secure Hash Algorithm** is ontwikkeld door het US National Institute of Standards and Technology (NIST), en er bestaan verschillende varianten afhankelijk van het gewenst aantal bits voor de output: SHA-224 (224 bits), SHA-256 (256 bits), SHA-384 (384 bits), SHA-512 (512 bits)

Uiteraard bestaan er ook nog vele andere hashing algoritmes

Test het zelf uit op http://www.fileformat.info/tool/hash.htm

---

## Botsingen

```
Hash(qwerty)        == 548d4efa8
Hash(ietsAnders)    == 548d4efa8
```

- Hashing algoritmes moeten in theorie altijd een andere output hebben voor verschillende inputs
- In de praktijk is dit niet steeds mogelijk, er zijn immers veel meer mogelijke inputs dan outputs (met vast aantal bits)
- Wanneer je voor 2 **verschillende inputs dezelfde output** waarde krijgt, spreekt men van een **botsing of collision**
- Een hashing algoritme verliest zijn nut als botsingen **bewust** veroorzaakt kunnen worden

---

## Sterke en zwakke algoritmes

Hashing algoritmes kunnen onderverdeeld worden in zwakke en sterke hashing algoritmes
- **MD5** en **SHA-1** zijn **zwakke algoritmes** waarbij botsingen bewust veroorzaakt kunnen worden
https://csrc.nist.gov/projects/hash-functions
    - Praktisch voorbeeld: https://www.mscs.dal.ca/~selinger/md5collision/ 
- Zwakke algoritmes zijn niet (meer) bruikbaar voor cybersecurity doeleinden
- **SHA-2** en **SHA-3** zijn **sterke algoritmes** die wel nog gebruikt worden voor cybersecurity doeleinden

Notes: 
- Voorbeelden van goede (sterke) hashing algoritmes zijn SHA-256, SHA-384 en SHA-512. Op https://www.mscs.dal.ca/~selinger/md5collision/ kan je een voorbeeld zien van 2 programma's "hello.exe" en "erase.exe" die dezelfde hashwaarde hebben, maar als je ze uitvoert toch iets anders tonen. Dit kan gevaarlijk zijn: een aanvaller kan een kwaadaardig programma maken met dezelfde hash als het oorspronkelijke programma en dat dan verspreiden. Gebruikers kunnen dan op basis van de hash niet meer detecteren of het gedownloade programma overeenkomt met het oorspronkelijke programma. Het bewust uitkomen van dezelfde hash voor 2 verschillende bitreeksen noemt een collision. Dit is de reden waarom MD5 en SHA-1 niet meer bruikbaar zijn, er kunnen bij deze hashing algoritmes collisions uitgelokt worden. 

---

# 5.3 Toepassingen van hashing algoritmes

---

## Toepassingen hashing algoritmes

- **Controle op fouten** in data
- Het **veilig bewaren** en controleren van **wachtwoorden**
- Identificeren van data aan de hand van een kleinere waarde (hash als **fingerprint**)
- Efficiënte opslag van data in **hashtabellen** (zie OLOD Classic Computer Science Algorithms)

---

## Controle op fouten

- Via een hashing algoritme kan je van een digitaal bestand de **hashwaarde berekenen** en dit toevoegen aan het bestand of publiceren op een website
- De hashwaarde kan op een later moment **opnieuw berekend** worden, bijvoorbeeld na downloaden van het bestand van een server
- Indien de nieuwe hashwaarde verschillend is, is het bestand gewijzigd en dus mogelijks onbruikbaar (bv. door een fout tijdens de download)

---

## Controle op fouten

<div class="multicolumn">
<div>

<img src="./img/h5/checksum.png" class="r-stretch" />

</div>
<div>

<img src="./img/h5/CPT_hashing_file_transmission.png" class="r-stretch" />


</div>
</div>

---

## Veilig bewaren van wachtwoorden
- Gebruikersnaam en wachtwoord worden vaak bewaard in **databanken**
- Databanken zijn een efficiënte manier om data op te slaan, analyseren en op te vragen


<div class="multicolumn">
<div>

<img src="./img/h5/DVD_rental_query.png"  />

</div>
<div>

<img src="./img/h5/sql_editor_overview.png" class="r-stretch" />

</div>
</div>

---

## Veilig bewaren van wachtwoorden

- Databanken zijn een gewild doelwit van cybercriminelen
- Een gelekte hoeveelheid gegevens uit een databank noemt een **Data Breach** (datalek)
- Als zo een lek **gebruikersnamen en wachtwoorden** bevat, zullen cybercriminelen die uittesten op andere website – dit is een grote oorzaak van hacks
- Hetzelfde wachtwoord hergebruiken is dus sterk afgeraden!
- Een wachtwoord dat je telkens lichtjes aanpast per website heeft ook geen zin
- Gebruik bij voorkeur een **wachtwoordmanager** en maak een uniek wachtwoord per website! 

Test jezelf op https://haveibeenpwned.com/ 

Notes: 
- Door de groei van data collectie en de vaak vertrouwelijke aard van data, is het belangrijk voor cybersecurity personeel om het steeds groeiend aantal databanken te beschermen. Databanken zijn een gewild doelwit van cybercriminelen. Een gelekte hoeveelheid gegevens uit een databank noemt een Data Breach (datalek).

- Vele mensen hergebruiken nog steeds dezelfde username (vaak hun e-mailadres) en wachtwoord. Als deze combinatie wordt gevonden in een data breach, wordt deze door cybercriminelen getest op andere websites. Dit is een grote oorzaak van hacks. Daarom gebruik je dus best een verschillend wachtwoord voor elke website. Het gebruik van 1 wachtwoord dat je telkens lichtjes aanpast per website heeft geen zin. De software van cybercriminelen houdt hier rekening mee. Gebruik dus bij voorkeur een wachtwoordmanager en maak een uniek wachtwoord per website! 

- Op https://haveibeenpwned.com kan je trouwens opzoeken of jouw e-mailadres ooit voorkwam in een gekende data breach.


---

## Veilig bewaren van wachtwoorden

<div class="multicolumn">
<div>

<img src="./img/h5/yahoo_data_breach.png"  />

</div>
<div>

<img src="./img/h5/linkedin_data_breach.png" class="r-stretch" />

</div>
</div>

Notes:
- https://www.csoonline.com/article/2130877/the-biggest-data-breaches-of-the-21st-century.html
- https://www.cbsnews.com/news/millions-facebook-user-records-exposed-amazon-cloud-server/

---

## Veilig bewaren van wachtwoorden

- *Poging 1*: we slaan de gebruikersnaam en het wachtwoord gewoon op in de databank, bij het inloggen moeten we dan het volgende controleren:
    - Ingevulde gebruikersnaam == gebruikersnaam in databank?
    - Ingevulde wachtwoord == wachtwoord in databank?
- Wordt ook **"plaintext"** opslag genoemd
- Eenvoudig
- Iemand met toegang tot de databank kan alle wachtwoorden uitlezen: **GEVAARLIJK!**

| Gebruikersnaam    | Paswoord                   |
|-------------------|----------------------------|
| tom@gmail.com     | Dit is een ST3rk Paswoord! |
| hanne@outlook.com | zwakpaswoord               |

---

## Veilig bewaren van wachtwoorden
- *Poging 2*: we slaan de gebruikersnaam en de hashwaarde van het wachtwoord op in de databank. Bij inloggen moeten we gewoon het volgende controleren:
    - Ingevulde gebruikersnaam == gebruikersnaam in databank?
    - Hash(wachtwoord) == hashwaarde in databank?
- Iets complexer, maar hashwaarden kunnen snel berekend worden
- Het plaintext wachtwoord wordt nooit opgeslagen
- Iemand met (al dan niet geautoriseerde) toegang tot de databank kan de wachtwoorden NIET uitlezen: **VEILIG!**

| Gebruikersnaam | Paswoord |
|---|---|
| tom@gmail.com | b30ead2d465295b... |
| hanne@outlook.com | 78062a5218ad971fb... |

---

## Salting

- Wanneer 2 gebruikers **hetzelfde wachtwoord** gebruiken, zal voor beiden **dezelfde hashwaarde** worden opgeslagen
- Hierdoor weten aanvallers dat ze door 1 wachtwoord te kraken 2 vliegen in 1 klap slaan
- **Salting** is een extra maatregel om hashing veiliger te maken
- Een **salt** is een random reeks bits die wordt **toegevoegd** aan het wachtwoord voordat de hash berekend wordt
Zo zullen gebruikers een **verschillende hash** hebben wanneer ze **hetzelfde wachtwoord** gebruiken

<img src="./img/h5/password-salt-example.svg"  />

